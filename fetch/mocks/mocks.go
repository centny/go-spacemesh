// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -typed -package=mocks -destination=./mocks/mocks.go -source=./interface.go
//
// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	types "github.com/spacemeshos/go-spacemesh/common/types"
	p2p "github.com/spacemeshos/go-spacemesh/p2p"
	gomock "go.uber.org/mock/gomock"
)

// Mockrequester is a mock of requester interface.
type Mockrequester struct {
	ctrl     *gomock.Controller
	recorder *MockrequesterMockRecorder
}

// MockrequesterMockRecorder is the mock recorder for Mockrequester.
type MockrequesterMockRecorder struct {
	mock *Mockrequester
}

// NewMockrequester creates a new mock instance.
func NewMockrequester(ctrl *gomock.Controller) *Mockrequester {
	mock := &Mockrequester{ctrl: ctrl}
	mock.recorder = &MockrequesterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockrequester) EXPECT() *MockrequesterMockRecorder {
	return m.recorder
}

// Request mocks base method.
func (m *Mockrequester) Request(arg0 context.Context, arg1 p2p.Peer, arg2 []byte, arg3 func([]byte), arg4 func(error)) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Request", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// Request indicates an expected call of Request.
func (mr *MockrequesterMockRecorder) Request(arg0, arg1, arg2, arg3, arg4 any) *requesterRequestCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Request", reflect.TypeOf((*Mockrequester)(nil).Request), arg0, arg1, arg2, arg3, arg4)
	return &requesterRequestCall{Call: call}
}

// requesterRequestCall wrap *gomock.Call
type requesterRequestCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *requesterRequestCall) Return(arg0 error) *requesterRequestCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *requesterRequestCall) Do(f func(context.Context, p2p.Peer, []byte, func([]byte), func(error)) error) *requesterRequestCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *requesterRequestCall) DoAndReturn(f func(context.Context, p2p.Peer, []byte, func([]byte), func(error)) error) *requesterRequestCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockSyncValidator is a mock of SyncValidator interface.
type MockSyncValidator struct {
	ctrl     *gomock.Controller
	recorder *MockSyncValidatorMockRecorder
}

// MockSyncValidatorMockRecorder is the mock recorder for MockSyncValidator.
type MockSyncValidatorMockRecorder struct {
	mock *MockSyncValidator
}

// NewMockSyncValidator creates a new mock instance.
func NewMockSyncValidator(ctrl *gomock.Controller) *MockSyncValidator {
	mock := &MockSyncValidator{ctrl: ctrl}
	mock.recorder = &MockSyncValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSyncValidator) EXPECT() *MockSyncValidatorMockRecorder {
	return m.recorder
}

// HandleMessage mocks base method.
func (m *MockSyncValidator) HandleMessage(arg0 context.Context, arg1 types.Hash32, arg2 p2p.Peer, arg3 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HandleMessage", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// HandleMessage indicates an expected call of HandleMessage.
func (mr *MockSyncValidatorMockRecorder) HandleMessage(arg0, arg1, arg2, arg3 any) *SyncValidatorHandleMessageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleMessage", reflect.TypeOf((*MockSyncValidator)(nil).HandleMessage), arg0, arg1, arg2, arg3)
	return &SyncValidatorHandleMessageCall{Call: call}
}

// SyncValidatorHandleMessageCall wrap *gomock.Call
type SyncValidatorHandleMessageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *SyncValidatorHandleMessageCall) Return(arg0 error) *SyncValidatorHandleMessageCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *SyncValidatorHandleMessageCall) Do(f func(context.Context, types.Hash32, p2p.Peer, []byte) error) *SyncValidatorHandleMessageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *SyncValidatorHandleMessageCall) DoAndReturn(f func(context.Context, types.Hash32, p2p.Peer, []byte) error) *SyncValidatorHandleMessageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockPoetValidator is a mock of PoetValidator interface.
type MockPoetValidator struct {
	ctrl     *gomock.Controller
	recorder *MockPoetValidatorMockRecorder
}

// MockPoetValidatorMockRecorder is the mock recorder for MockPoetValidator.
type MockPoetValidatorMockRecorder struct {
	mock *MockPoetValidator
}

// NewMockPoetValidator creates a new mock instance.
func NewMockPoetValidator(ctrl *gomock.Controller) *MockPoetValidator {
	mock := &MockPoetValidator{ctrl: ctrl}
	mock.recorder = &MockPoetValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPoetValidator) EXPECT() *MockPoetValidatorMockRecorder {
	return m.recorder
}

// ValidateAndStoreMsg mocks base method.
func (m *MockPoetValidator) ValidateAndStoreMsg(arg0 context.Context, arg1 types.Hash32, arg2 p2p.Peer, arg3 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateAndStoreMsg", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateAndStoreMsg indicates an expected call of ValidateAndStoreMsg.
func (mr *MockPoetValidatorMockRecorder) ValidateAndStoreMsg(arg0, arg1, arg2, arg3 any) *PoetValidatorValidateAndStoreMsgCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateAndStoreMsg", reflect.TypeOf((*MockPoetValidator)(nil).ValidateAndStoreMsg), arg0, arg1, arg2, arg3)
	return &PoetValidatorValidateAndStoreMsgCall{Call: call}
}

// PoetValidatorValidateAndStoreMsgCall wrap *gomock.Call
type PoetValidatorValidateAndStoreMsgCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PoetValidatorValidateAndStoreMsgCall) Return(arg0 error) *PoetValidatorValidateAndStoreMsgCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PoetValidatorValidateAndStoreMsgCall) Do(f func(context.Context, types.Hash32, p2p.Peer, []byte) error) *PoetValidatorValidateAndStoreMsgCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PoetValidatorValidateAndStoreMsgCall) DoAndReturn(f func(context.Context, types.Hash32, p2p.Peer, []byte) error) *PoetValidatorValidateAndStoreMsgCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockmeshProvider is a mock of meshProvider interface.
type MockmeshProvider struct {
	ctrl     *gomock.Controller
	recorder *MockmeshProviderMockRecorder
}

// MockmeshProviderMockRecorder is the mock recorder for MockmeshProvider.
type MockmeshProviderMockRecorder struct {
	mock *MockmeshProvider
}

// NewMockmeshProvider creates a new mock instance.
func NewMockmeshProvider(ctrl *gomock.Controller) *MockmeshProvider {
	mock := &MockmeshProvider{ctrl: ctrl}
	mock.recorder = &MockmeshProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmeshProvider) EXPECT() *MockmeshProviderMockRecorder {
	return m.recorder
}

// LastVerified mocks base method.
func (m *MockmeshProvider) LastVerified() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastVerified")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// LastVerified indicates an expected call of LastVerified.
func (mr *MockmeshProviderMockRecorder) LastVerified() *meshProviderLastVerifiedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastVerified", reflect.TypeOf((*MockmeshProvider)(nil).LastVerified))
	return &meshProviderLastVerifiedCall{Call: call}
}

// meshProviderLastVerifiedCall wrap *gomock.Call
type meshProviderLastVerifiedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshProviderLastVerifiedCall) Return(arg0 types.LayerID) *meshProviderLastVerifiedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshProviderLastVerifiedCall) Do(f func() types.LayerID) *meshProviderLastVerifiedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshProviderLastVerifiedCall) DoAndReturn(f func() types.LayerID) *meshProviderLastVerifiedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockhost is a mock of host interface.
type Mockhost struct {
	ctrl     *gomock.Controller
	recorder *MockhostMockRecorder
}

// MockhostMockRecorder is the mock recorder for Mockhost.
type MockhostMockRecorder struct {
	mock *Mockhost
}

// NewMockhost creates a new mock instance.
func NewMockhost(ctrl *gomock.Controller) *Mockhost {
	mock := &Mockhost{ctrl: ctrl}
	mock.recorder = &MockhostMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockhost) EXPECT() *MockhostMockRecorder {
	return m.recorder
}

// ID mocks base method.
func (m *Mockhost) ID() p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(p2p.Peer)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockhostMockRecorder) ID() *hostIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*Mockhost)(nil).ID))
	return &hostIDCall{Call: call}
}

// hostIDCall wrap *gomock.Call
type hostIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *hostIDCall) Return(arg0 p2p.Peer) *hostIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *hostIDCall) Do(f func() p2p.Peer) *hostIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *hostIDCall) DoAndReturn(f func() p2p.Peer) *hostIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocklayerClock is a mock of layerClock interface.
type MocklayerClock struct {
	ctrl     *gomock.Controller
	recorder *MocklayerClockMockRecorder
}

// MocklayerClockMockRecorder is the mock recorder for MocklayerClock.
type MocklayerClockMockRecorder struct {
	mock *MocklayerClock
}

// NewMocklayerClock creates a new mock instance.
func NewMocklayerClock(ctrl *gomock.Controller) *MocklayerClock {
	mock := &MocklayerClock{ctrl: ctrl}
	mock.recorder = &MocklayerClockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocklayerClock) EXPECT() *MocklayerClockMockRecorder {
	return m.recorder
}

// AwaitLayer mocks base method.
func (m *MocklayerClock) AwaitLayer(layerID types.LayerID) <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AwaitLayer", layerID)
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// AwaitLayer indicates an expected call of AwaitLayer.
func (mr *MocklayerClockMockRecorder) AwaitLayer(layerID any) *layerClockAwaitLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AwaitLayer", reflect.TypeOf((*MocklayerClock)(nil).AwaitLayer), layerID)
	return &layerClockAwaitLayerCall{Call: call}
}

// layerClockAwaitLayerCall wrap *gomock.Call
type layerClockAwaitLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *layerClockAwaitLayerCall) Return(arg0 <-chan struct{}) *layerClockAwaitLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *layerClockAwaitLayerCall) Do(f func(types.LayerID) <-chan struct{}) *layerClockAwaitLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *layerClockAwaitLayerCall) DoAndReturn(f func(types.LayerID) <-chan struct{}) *layerClockAwaitLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentLayer mocks base method.
func (m *MocklayerClock) CurrentLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// CurrentLayer indicates an expected call of CurrentLayer.
func (mr *MocklayerClockMockRecorder) CurrentLayer() *layerClockCurrentLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentLayer", reflect.TypeOf((*MocklayerClock)(nil).CurrentLayer))
	return &layerClockCurrentLayerCall{Call: call}
}

// layerClockCurrentLayerCall wrap *gomock.Call
type layerClockCurrentLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *layerClockCurrentLayerCall) Return(arg0 types.LayerID) *layerClockCurrentLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *layerClockCurrentLayerCall) Do(f func() types.LayerID) *layerClockCurrentLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *layerClockCurrentLayerCall) DoAndReturn(f func() types.LayerID) *layerClockCurrentLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LayerToTime mocks base method.
func (m *MocklayerClock) LayerToTime(arg0 types.LayerID) time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LayerToTime", arg0)
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// LayerToTime indicates an expected call of LayerToTime.
func (mr *MocklayerClockMockRecorder) LayerToTime(arg0 any) *layerClockLayerToTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LayerToTime", reflect.TypeOf((*MocklayerClock)(nil).LayerToTime), arg0)
	return &layerClockLayerToTimeCall{Call: call}
}

// layerClockLayerToTimeCall wrap *gomock.Call
type layerClockLayerToTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *layerClockLayerToTimeCall) Return(arg0 time.Time) *layerClockLayerToTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *layerClockLayerToTimeCall) Do(f func(types.LayerID) time.Time) *layerClockLayerToTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *layerClockLayerToTimeCall) DoAndReturn(f func(types.LayerID) time.Time) *layerClockLayerToTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
